// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: features.sql

package db

import (
	"context"
	"time"
)

const createFeature = `-- name: CreateFeature :one
INSERT INTO features (name, description, service_id)
VALUES ($1, $2, $3)
RETURNING id
`

type CreateFeatureParams struct {
	Name        string
	Description string
	ServiceID   uint
}

func (q *Queries) CreateFeature(ctx context.Context, arg CreateFeatureParams) (uint, error) {
	row := q.db.QueryRow(ctx, createFeature, arg.Name, arg.Description, arg.ServiceID)
	var id uint
	err := row.Scan(&id)
	return id, err
}

const createFeatureVersion = `-- name: CreateFeatureVersion :one
INSERT INTO feature_versions (feature_id, version, valid_from)
VALUES ($1, $2, $3)
RETURNING id
`

type CreateFeatureVersionParams struct {
	FeatureID uint
	Version   int
	ValidFrom *time.Time
}

func (q *Queries) CreateFeatureVersion(ctx context.Context, arg CreateFeatureVersionParams) (uint, error) {
	row := q.db.QueryRow(ctx, createFeatureVersion, arg.FeatureID, arg.Version, arg.ValidFrom)
	var id uint
	err := row.Scan(&id)
	return id, err
}

const createFeatureVersionServiceVersion = `-- name: CreateFeatureVersionServiceVersion :one
INSERT INTO feature_version_service_versions (service_version_id, feature_version_id)
VALUES ($1, $2)
RETURNING id
`

type CreateFeatureVersionServiceVersionParams struct {
	ServiceVersionID uint
	FeatureVersionID uint
}

func (q *Queries) CreateFeatureVersionServiceVersion(ctx context.Context, arg CreateFeatureVersionServiceVersionParams) (uint, error) {
	row := q.db.QueryRow(ctx, createFeatureVersionServiceVersion, arg.ServiceVersionID, arg.FeatureVersionID)
	var id uint
	err := row.Scan(&id)
	return id, err
}

const getActiveFeatureVersionsForServiceVersion = `-- name: GetActiveFeatureVersionsForServiceVersion :many
SELECT fv.id,
    fv.feature_id,
    fv.version,
    f.name as feature_name,
    f.description as feature_description
FROM feature_version_service_versions fvsv
    JOIN feature_versions fv ON fv.id = fvsv.feature_version_id
    JOIN features f ON f.id = fv.feature_id
WHERE fvsv.service_version_id = $1
    AND (
        fvsv.valid_from IS NOT NULL
        AND fvsv.valid_to IS NULL
        AND NOT EXISTS (
            SELECT csc.id
            FROM changeset_changes csc
            WHERE csc.changeset_id = $2
                AND csc.type = 'create'
                AND csc.feature_version_service_version_id = fvsv.id
            LIMIT 1
        )
    )
    OR (
        fvsv.valid_from IS NULL
        AND EXISTS (
            SELECT csc.id
            FROM changeset_changes csc
            WHERE csc.changeset_id = $2
                AND csc.type = 'create'
                AND csc.feature_version_service_version_id = fvsv.id
            LIMIT 1
        )
    )
ORDER BY f.name
`

type GetActiveFeatureVersionsForServiceVersionParams struct {
	ServiceVersionID uint
	ChangesetID      uint
}

type GetActiveFeatureVersionsForServiceVersionRow struct {
	ID                 uint
	FeatureID          uint
	Version            int
	FeatureName        string
	FeatureDescription string
}

func (q *Queries) GetActiveFeatureVersionsForServiceVersion(ctx context.Context, arg GetActiveFeatureVersionsForServiceVersionParams) ([]GetActiveFeatureVersionsForServiceVersionRow, error) {
	rows, err := q.db.Query(ctx, getActiveFeatureVersionsForServiceVersion, arg.ServiceVersionID, arg.ChangesetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveFeatureVersionsForServiceVersionRow
	for rows.Next() {
		var i GetActiveFeatureVersionsForServiceVersionRow
		if err := rows.Scan(
			&i.ID,
			&i.FeatureID,
			&i.Version,
			&i.FeatureName,
			&i.FeatureDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFeatureIDByName = `-- name: GetFeatureIDByName :one
SELECT id
FROM features
WHERE name = $1
`

func (q *Queries) GetFeatureIDByName(ctx context.Context, name string) (uint, error) {
	row := q.db.QueryRow(ctx, getFeatureIDByName, name)
	var id uint
	err := row.Scan(&id)
	return id, err
}

const getFeatureVersion = `-- name: GetFeatureVersion :one
SELECT fv.id, fv.created_at, fv.updated_at, fv.valid_from, fv.valid_to, fv.version, fv.feature_id,
    f.name as feature_name,
    f.description as feature_description
FROM feature_versions fv
    JOIN features f ON f.id = fv.feature_id
WHERE fv.id = $1
LIMIT 1
`

type GetFeatureVersionRow struct {
	ID                 uint
	CreatedAt          time.Time
	UpdatedAt          time.Time
	ValidFrom          *time.Time
	ValidTo            *time.Time
	Version            int
	FeatureID          uint
	FeatureName        string
	FeatureDescription string
}

func (q *Queries) GetFeatureVersion(ctx context.Context, featureVersionID uint) (GetFeatureVersionRow, error) {
	row := q.db.QueryRow(ctx, getFeatureVersion, featureVersionID)
	var i GetFeatureVersionRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ValidFrom,
		&i.ValidTo,
		&i.Version,
		&i.FeatureID,
		&i.FeatureName,
		&i.FeatureDescription,
	)
	return i, err
}

const getFeatureVersionsLinkedToServiceVersion = `-- name: GetFeatureVersionsLinkedToServiceVersion :many
SELECT fv.id,
    fv.version
FROM feature_version_service_versions fvsv
    JOIN feature_versions fv ON fvsv.feature_version_id = fv.id
    JOIN features f ON f.id = fv.feature_id
WHERE fv.feature_id = $1
    AND fvsv.service_version_id = $2
    AND (
        fv.valid_from IS NOT NULL
        OR (
            fv.valid_from IS NULL
            AND EXISTS (
                SELECT csc.id
                FROM changeset_changes csc
                WHERE csc.changeset_id = $3
                    AND csc.type = 'create'
                    AND csc.feature_version_id = fv.id
                LIMIT 1
            )
        )
    )
ORDER BY fv.version
`

type GetFeatureVersionsLinkedToServiceVersionParams struct {
	FeatureID        uint
	ServiceVersionID uint
	ChangesetID      uint
}

type GetFeatureVersionsLinkedToServiceVersionRow struct {
	ID      uint
	Version int
}

func (q *Queries) GetFeatureVersionsLinkedToServiceVersion(ctx context.Context, arg GetFeatureVersionsLinkedToServiceVersionParams) ([]GetFeatureVersionsLinkedToServiceVersionRow, error) {
	rows, err := q.db.Query(ctx, getFeatureVersionsLinkedToServiceVersion, arg.FeatureID, arg.ServiceVersionID, arg.ChangesetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFeatureVersionsLinkedToServiceVersionRow
	for rows.Next() {
		var i GetFeatureVersionsLinkedToServiceVersionRow
		if err := rows.Scan(&i.ID, &i.Version); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
