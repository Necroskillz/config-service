// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: changeset.sql

package db

import (
	"context"
	"time"
)

type AddChangesParams struct {
	ChangesetID         uint
	NewVariationValueID *uint
	OldVariationValueID *uint
	KeyID               *uint
	FeatureVersionID    *uint
	ServiceVersionID    uint
	Type                ChangesetChangeType
	Kind                ChangesetChangeKind
}

const addChangesetAction = `-- name: AddChangesetAction :exec
INSERT INTO changeset_actions(changeset_id, user_id, type, comment)
    VALUES ($1, $2, $3, $4)
`

type AddChangesetActionParams struct {
	ChangesetID uint
	UserID      uint
	Type        ChangesetActionType
	Comment     *string
}

func (q *Queries) AddChangesetAction(ctx context.Context, arg AddChangesetActionParams) error {
	_, err := q.db.Exec(ctx, addChangesetAction,
		arg.ChangesetID,
		arg.UserID,
		arg.Type,
		arg.Comment,
	)
	return err
}

const addCreateFeatureVersionChange = `-- name: AddCreateFeatureVersionChange :exec
INSERT INTO changeset_changes(changeset_id, feature_version_id, previous_feature_version_id, service_version_id, type, kind)
    VALUES ($1, $2::bigint, $3, $4::bigint, 'create', 'feature_version')
`

type AddCreateFeatureVersionChangeParams struct {
	ChangesetID              uint
	FeatureVersionID         uint
	PreviousFeatureVersionID *uint
	ServiceVersionID         uint
}

func (q *Queries) AddCreateFeatureVersionChange(ctx context.Context, arg AddCreateFeatureVersionChangeParams) error {
	_, err := q.db.Exec(ctx, addCreateFeatureVersionChange,
		arg.ChangesetID,
		arg.FeatureVersionID,
		arg.PreviousFeatureVersionID,
		arg.ServiceVersionID,
	)
	return err
}

const addCreateFeatureVersionServiceVersionChange = `-- name: AddCreateFeatureVersionServiceVersionChange :exec
INSERT INTO changeset_changes(changeset_id, feature_version_service_version_id, feature_version_id, service_version_id, type, kind)
    VALUES ($1, $2::bigint, $3::bigint, $4::bigint, 'create', 'feature_version_service_version')
`

type AddCreateFeatureVersionServiceVersionChangeParams struct {
	ChangesetID                    uint
	FeatureVersionServiceVersionID uint
	FeatureVersionID               uint
	ServiceVersionID               uint
}

func (q *Queries) AddCreateFeatureVersionServiceVersionChange(ctx context.Context, arg AddCreateFeatureVersionServiceVersionChangeParams) error {
	_, err := q.db.Exec(ctx, addCreateFeatureVersionServiceVersionChange,
		arg.ChangesetID,
		arg.FeatureVersionServiceVersionID,
		arg.FeatureVersionID,
		arg.ServiceVersionID,
	)
	return err
}

const addCreateKeyChange = `-- name: AddCreateKeyChange :exec
INSERT INTO changeset_changes(changeset_id, key_id, feature_version_id, service_version_id, type, kind)
    VALUES ($1, $2::bigint, $3::bigint, $4::bigint, 'create', 'key')
`

type AddCreateKeyChangeParams struct {
	ChangesetID      uint
	KeyID            uint
	FeatureVersionID uint
	ServiceVersionID uint
}

func (q *Queries) AddCreateKeyChange(ctx context.Context, arg AddCreateKeyChangeParams) error {
	_, err := q.db.Exec(ctx, addCreateKeyChange,
		arg.ChangesetID,
		arg.KeyID,
		arg.FeatureVersionID,
		arg.ServiceVersionID,
	)
	return err
}

const addCreateServiceVersionChange = `-- name: AddCreateServiceVersionChange :exec
INSERT INTO changeset_changes(changeset_id, service_version_id, previous_service_version_id, type, kind)
    VALUES ($1, $2::bigint, $3, 'create', 'service_version')
`

type AddCreateServiceVersionChangeParams struct {
	ChangesetID              uint
	ServiceVersionID         uint
	PreviousServiceVersionID *uint
}

func (q *Queries) AddCreateServiceVersionChange(ctx context.Context, arg AddCreateServiceVersionChangeParams) error {
	_, err := q.db.Exec(ctx, addCreateServiceVersionChange, arg.ChangesetID, arg.ServiceVersionID, arg.PreviousServiceVersionID)
	return err
}

const addCreateVariationValueChange = `-- name: AddCreateVariationValueChange :exec
INSERT INTO changeset_changes(changeset_id, new_variation_value_id, feature_version_id, key_id, service_version_id, type, kind)
    VALUES ($1, $2::bigint, $3::bigint, $4::bigint, $5::bigint, 'create', 'variation_value')
`

type AddCreateVariationValueChangeParams struct {
	ChangesetID         uint
	NewVariationValueID uint
	FeatureVersionID    uint
	KeyID               uint
	ServiceVersionID    uint
}

func (q *Queries) AddCreateVariationValueChange(ctx context.Context, arg AddCreateVariationValueChangeParams) error {
	_, err := q.db.Exec(ctx, addCreateVariationValueChange,
		arg.ChangesetID,
		arg.NewVariationValueID,
		arg.FeatureVersionID,
		arg.KeyID,
		arg.ServiceVersionID,
	)
	return err
}

const addDeleteFeatureVersionServiceVersionChange = `-- name: AddDeleteFeatureVersionServiceVersionChange :exec
INSERT INTO changeset_changes(changeset_id, feature_version_service_version_id, feature_version_id, service_version_id, type, kind)
    VALUES ($1, $2::bigint, $3::bigint, $4::bigint, 'delete', 'feature_version_service_version')
`

type AddDeleteFeatureVersionServiceVersionChangeParams struct {
	ChangesetID                    uint
	FeatureVersionServiceVersionID uint
	FeatureVersionID               uint
	ServiceVersionID               uint
}

func (q *Queries) AddDeleteFeatureVersionServiceVersionChange(ctx context.Context, arg AddDeleteFeatureVersionServiceVersionChangeParams) error {
	_, err := q.db.Exec(ctx, addDeleteFeatureVersionServiceVersionChange,
		arg.ChangesetID,
		arg.FeatureVersionServiceVersionID,
		arg.FeatureVersionID,
		arg.ServiceVersionID,
	)
	return err
}

const addDeleteKeyChange = `-- name: AddDeleteKeyChange :exec
INSERT INTO changeset_changes(changeset_id, key_id, feature_version_id, service_version_id, type, kind)
    VALUES ($1, $2::bigint, $3::bigint, $4::bigint, 'delete', 'key')
`

type AddDeleteKeyChangeParams struct {
	ChangesetID      uint
	KeyID            uint
	FeatureVersionID uint
	ServiceVersionID uint
}

func (q *Queries) AddDeleteKeyChange(ctx context.Context, arg AddDeleteKeyChangeParams) error {
	_, err := q.db.Exec(ctx, addDeleteKeyChange,
		arg.ChangesetID,
		arg.KeyID,
		arg.FeatureVersionID,
		arg.ServiceVersionID,
	)
	return err
}

const addDeleteVariationValueChange = `-- name: AddDeleteVariationValueChange :exec
INSERT INTO changeset_changes(changeset_id, old_variation_value_id, feature_version_id, key_id, service_version_id, type, kind)
    VALUES ($1, $2::bigint, $3::bigint, $4::bigint, $5::bigint, 'delete', 'variation_value')
`

type AddDeleteVariationValueChangeParams struct {
	ChangesetID         uint
	OldVariationValueID uint
	FeatureVersionID    uint
	KeyID               uint
	ServiceVersionID    uint
}

func (q *Queries) AddDeleteVariationValueChange(ctx context.Context, arg AddDeleteVariationValueChangeParams) error {
	_, err := q.db.Exec(ctx, addDeleteVariationValueChange,
		arg.ChangesetID,
		arg.OldVariationValueID,
		arg.FeatureVersionID,
		arg.KeyID,
		arg.ServiceVersionID,
	)
	return err
}

const addUpdateVariationValueChange = `-- name: AddUpdateVariationValueChange :exec
INSERT INTO changeset_changes(changeset_id, new_variation_value_id, old_variation_value_id, feature_version_id, key_id, service_version_id, type, kind)
    VALUES ($1, $2::bigint, $3::bigint, $4::bigint, $5::bigint, $6::bigint, 'update', 'variation_value')
`

type AddUpdateVariationValueChangeParams struct {
	ChangesetID         uint
	NewVariationValueID uint
	OldVariationValueID uint
	FeatureVersionID    uint
	KeyID               uint
	ServiceVersionID    uint
}

func (q *Queries) AddUpdateVariationValueChange(ctx context.Context, arg AddUpdateVariationValueChangeParams) error {
	_, err := q.db.Exec(ctx, addUpdateVariationValueChange,
		arg.ChangesetID,
		arg.NewVariationValueID,
		arg.OldVariationValueID,
		arg.FeatureVersionID,
		arg.KeyID,
		arg.ServiceVersionID,
	)
	return err
}

const createChangeset = `-- name: CreateChangeset :one
INSERT INTO changesets(user_id, state)
    VALUES ($1, 'open')
RETURNING
    id
`

func (q *Queries) CreateChangeset(ctx context.Context, userID uint) (uint, error) {
	row := q.db.QueryRow(ctx, createChangeset, userID)
	var id uint
	err := row.Scan(&id)
	return id, err
}

const deleteChange = `-- name: DeleteChange :exec
DELETE FROM changeset_changes
WHERE id = $1
`

func (q *Queries) DeleteChange(ctx context.Context, changeID uint) error {
	_, err := q.db.Exec(ctx, deleteChange, changeID)
	return err
}

const deleteChangesForChangeset = `-- name: DeleteChangesForChangeset :exec
DELETE FROM changeset_changes
WHERE changeset_id = $1
`

func (q *Queries) DeleteChangesForChangeset(ctx context.Context, changesetID uint) error {
	_, err := q.db.Exec(ctx, deleteChangesForChangeset, changesetID)
	return err
}

const getApprovableChangesetCount = `-- name: GetApprovableChangesetCount :one
WITH changeset_services AS (
    SELECT DISTINCT
        cs.id,
        sv.service_id
    FROM
        changesets cs
        JOIN changeset_changes csc ON csc.changeset_id = cs.id
        JOIN service_versions sv ON sv.id = csc.service_version_id
    WHERE
        cs.state = 'committed'
),
user_service_permissions AS (
    SELECT DISTINCT
        service_id
    FROM
        users u
        LEFT JOIN user_group_memberships ugm ON ugm.user_id = u.id
        JOIN permissions p ON p.user_group_id = ugm.user_group_id
            OR p.user_id = u.id
    WHERE
        p.kind = 'service'
        AND u.id = $1
        AND p.permission = 'admin'
)
SELECT
    COUNT(DISTINCT cs.id)::integer
FROM
    changeset_services cs
WHERE
    NOT EXISTS (
        SELECT
            1
        FROM
            changeset_services sub
        WHERE
            sub.id = cs.id
            AND sub.service_id NOT IN (
                SELECT
                    service_id
                FROM
                    user_service_permissions))
`

func (q *Queries) GetApprovableChangesetCount(ctx context.Context, userID uint) (int, error) {
	row := q.db.QueryRow(ctx, getApprovableChangesetCount, userID)
	var column_1 int
	err := row.Scan(&column_1)
	return column_1, err
}

const getChangeForFeatureVersionServiceVersion = `-- name: GetChangeForFeatureVersionServiceVersion :one
SELECT
    csc.id,
    csc.type,
    csc.feature_version_service_version_id
FROM
    changeset_changes csc
WHERE
    csc.changeset_id = $1
    AND csc.service_version_id = $2::bigint
    AND csc.feature_version_id = $3::bigint
    AND csc.kind = 'feature_version_service_version'
LIMIT 1
`

type GetChangeForFeatureVersionServiceVersionParams struct {
	ChangesetID      uint
	ServiceVersionID uint
	FeatureVersionID uint
}

type GetChangeForFeatureVersionServiceVersionRow struct {
	ID                             uint
	Type                           ChangesetChangeType
	FeatureVersionServiceVersionID *uint
}

func (q *Queries) GetChangeForFeatureVersionServiceVersion(ctx context.Context, arg GetChangeForFeatureVersionServiceVersionParams) (GetChangeForFeatureVersionServiceVersionRow, error) {
	row := q.db.QueryRow(ctx, getChangeForFeatureVersionServiceVersion, arg.ChangesetID, arg.ServiceVersionID, arg.FeatureVersionID)
	var i GetChangeForFeatureVersionServiceVersionRow
	err := row.Scan(&i.ID, &i.Type, &i.FeatureVersionServiceVersionID)
	return i, err
}

const getChangeForKey = `-- name: GetChangeForKey :one
SELECT
    csc.id,
    csc.type,
    csc.key_id,
    csc.feature_version_id,
    csc.service_version_id
FROM
    changeset_changes csc
WHERE
    csc.changeset_id = $1
    AND csc.kind = 'key'
    AND csc.key_id = $2::bigint
LIMIT 1
`

type GetChangeForKeyParams struct {
	ChangesetID uint
	KeyID       uint
}

type GetChangeForKeyRow struct {
	ID               uint
	Type             ChangesetChangeType
	KeyID            *uint
	FeatureVersionID *uint
	ServiceVersionID uint
}

func (q *Queries) GetChangeForKey(ctx context.Context, arg GetChangeForKeyParams) (GetChangeForKeyRow, error) {
	row := q.db.QueryRow(ctx, getChangeForKey, arg.ChangesetID, arg.KeyID)
	var i GetChangeForKeyRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.KeyID,
		&i.FeatureVersionID,
		&i.ServiceVersionID,
	)
	return i, err
}

const getChangeForVariationValue = `-- name: GetChangeForVariationValue :one
SELECT
    csc.id,
    csc.type,
    nvv.id AS new_variation_value_id,
    ovv.id AS old_variation_value_id,
    COALESCE(nvv.variation_context_id, ovv.variation_context_id) AS variation_context_id,
    nvv.data AS new_variation_value_data,
    ovv.data AS old_variation_value_data
FROM
    changeset_changes csc
    LEFT JOIN variation_values nvv ON nvv.id = csc.new_variation_value_id
    LEFT JOIN variation_values ovv ON ovv.id = csc.old_variation_value_id
WHERE
    csc.changeset_id = $1
    AND (csc.old_variation_value_id = $2::bigint
        OR csc.new_variation_value_id = $2::bigint)
LIMIT 1
`

type GetChangeForVariationValueParams struct {
	ChangesetID      uint
	VariationValueID uint
}

type GetChangeForVariationValueRow struct {
	ID                    uint
	Type                  ChangesetChangeType
	NewVariationValueID   *uint
	OldVariationValueID   *uint
	VariationContextID    uint
	NewVariationValueData *string
	OldVariationValueData *string
}

func (q *Queries) GetChangeForVariationValue(ctx context.Context, arg GetChangeForVariationValueParams) (GetChangeForVariationValueRow, error) {
	row := q.db.QueryRow(ctx, getChangeForVariationValue, arg.ChangesetID, arg.VariationValueID)
	var i GetChangeForVariationValueRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.NewVariationValueID,
		&i.OldVariationValueID,
		&i.VariationContextID,
		&i.NewVariationValueData,
		&i.OldVariationValueData,
	)
	return i, err
}

const getChangeHistory = `-- name: GetChangeHistory :many
SELECT
    csc.id,
    csc.type,
    csc.kind,
    cs.applied_at::timestamptz AS applied_at,
    u.name AS user_name,
    u.id AS user_id,
    cs.id AS changeset_id,
    sv.id AS service_version_id,
    csc.previous_service_version_id,
    s.name AS service_name,
    s.id AS service_id,
    sv.version AS service_version,
    fv.id AS feature_version_id,
    csc.previous_feature_version_id,
    f.name AS feature_name,
    f.id AS feature_id,
    fv.version AS feature_version,
    k.id AS key_id,
    k.name AS key_name,
    nv.id AS new_variation_value_id,
    nv.data AS new_variation_value_data,
    ov.id AS old_variation_value_id,
    ov.data AS old_variation_value_data,
    vc.id AS variation_context_id,
    COUNT(*) OVER ()::integer AS total_count
FROM
    changeset_changes csc
    JOIN changesets cs ON cs.id = csc.changeset_id
    JOIN service_versions sv ON sv.id = csc.service_version_id
    JOIN services s ON s.id = sv.service_id
    JOIN users u ON u.id = cs.user_id
    LEFT JOIN feature_version_service_versions fvsv ON fvsv.id = csc.feature_version_service_version_id
    LEFT JOIN feature_versions fv ON fv.id = csc.feature_version_id
    LEFT JOIN features f ON f.id = fv.feature_id
    LEFT JOIN keys k ON k.id = csc.key_id
    LEFT JOIN variation_values nv ON nv.id = csc.new_variation_value_id
    LEFT JOIN variation_values ov ON ov.id = csc.old_variation_value_id
    LEFT JOIN variation_contexts vc ON vc.id = COALESCE(nv.variation_context_id, ov.variation_context_id)
WHERE
    cs.applied_at IS NOT NULL
    AND ($1::bigint IS NULL OR s.id = $1::bigint)
    AND ($2::bigint IS NULL OR sv.id = $2::bigint)
    AND ($3::bigint IS NULL OR f.id = $3::bigint)
    AND ($4::bigint IS NULL OR fv.id = $4::bigint)
    AND ($5::text IS NULL OR k.name = $5::text)
    AND ($6::bigint IS NULL OR vc.id = $6::bigint)
    AND ($7::text[] IS NULL OR csc.kind = ANY($7::text[]::changeset_change_kind[]))
ORDER BY
    cs.applied_at DESC, csc.id DESC
LIMIT $9::integer OFFSET $8::integer
`

type GetChangeHistoryParams struct {
	ServiceID          *uint
	ServiceVersionID   *uint
	FeatureID          *uint
	FeatureVersionID   *uint
	KeyName            *string
	VariationContextID *uint
	Kinds              []string
	Offset             int
	Limit              int
}

type GetChangeHistoryRow struct {
	ID                       uint
	Type                     ChangesetChangeType
	Kind                     ChangesetChangeKind
	AppliedAt                time.Time
	UserName                 string
	UserID                   uint
	ChangesetID              uint
	ServiceVersionID         uint
	PreviousServiceVersionID *uint
	ServiceName              string
	ServiceID                uint
	ServiceVersion           int
	FeatureVersionID         *uint
	PreviousFeatureVersionID *uint
	FeatureName              *string
	FeatureID                *uint
	FeatureVersion           *int
	KeyID                    *uint
	KeyName                  *string
	NewVariationValueID      *uint
	NewVariationValueData    *string
	OldVariationValueID      *uint
	OldVariationValueData    *string
	VariationContextID       *uint
	TotalCount               int
}

func (q *Queries) GetChangeHistory(ctx context.Context, arg GetChangeHistoryParams) ([]GetChangeHistoryRow, error) {
	rows, err := q.db.Query(ctx, getChangeHistory,
		arg.ServiceID,
		arg.ServiceVersionID,
		arg.FeatureID,
		arg.FeatureVersionID,
		arg.KeyName,
		arg.VariationContextID,
		arg.Kinds,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChangeHistoryRow
	for rows.Next() {
		var i GetChangeHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Kind,
			&i.AppliedAt,
			&i.UserName,
			&i.UserID,
			&i.ChangesetID,
			&i.ServiceVersionID,
			&i.PreviousServiceVersionID,
			&i.ServiceName,
			&i.ServiceID,
			&i.ServiceVersion,
			&i.FeatureVersionID,
			&i.PreviousFeatureVersionID,
			&i.FeatureName,
			&i.FeatureID,
			&i.FeatureVersion,
			&i.KeyID,
			&i.KeyName,
			&i.NewVariationValueID,
			&i.NewVariationValueData,
			&i.OldVariationValueID,
			&i.OldVariationValueData,
			&i.VariationContextID,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChangeset = `-- name: GetChangeset :one
SELECT
    cs.id,
    cs.state,
    cs.applied_at,
    u.id AS user_id,
    u.name AS user_name
FROM
    changesets cs
    JOIN users u ON u.id = cs.user_id
WHERE
    cs.id = $1
LIMIT 1
`

type GetChangesetRow struct {
	ID        uint
	State     ChangesetState
	AppliedAt *time.Time
	UserID    uint
	UserName  string
}

func (q *Queries) GetChangeset(ctx context.Context, changesetID uint) (GetChangesetRow, error) {
	row := q.db.QueryRow(ctx, getChangeset, changesetID)
	var i GetChangesetRow
	err := row.Scan(
		&i.ID,
		&i.State,
		&i.AppliedAt,
		&i.UserID,
		&i.UserName,
	)
	return i, err
}

const getChangesetActions = `-- name: GetChangesetActions :many
SELECT
    ca.id,
    ca.type,
    ca.comment,
    ca.created_at,
    u.id AS user_id,
    u.name AS user_name
FROM
    changeset_actions ca
    JOIN users u ON u.id = ca.user_id
WHERE
    ca.changeset_id = $1
ORDER BY
    ca.id
`

type GetChangesetActionsRow struct {
	ID        uint
	Type      ChangesetActionType
	Comment   *string
	CreatedAt time.Time
	UserID    uint
	UserName  string
}

func (q *Queries) GetChangesetActions(ctx context.Context, changesetID uint) ([]GetChangesetActionsRow, error) {
	rows, err := q.db.Query(ctx, getChangesetActions, changesetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChangesetActionsRow
	for rows.Next() {
		var i GetChangesetActionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Comment,
			&i.CreatedAt,
			&i.UserID,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChangesetChange = `-- name: GetChangesetChange :one
SELECT
    csc.id, csc.created_at, csc.changeset_id, csc.type, csc.kind, csc.feature_version_id, csc.previous_feature_version_id, csc.service_version_id, csc.previous_service_version_id, csc.feature_version_service_version_id, csc.key_id, csc.new_variation_value_id, csc.old_variation_value_id,
    vv.variation_context_id AS variation_context_id
FROM
    changeset_changes csc
    LEFT JOIN variation_values vv ON vv.id = COALESCE(csc.new_variation_value_id, csc.old_variation_value_id)
WHERE
    csc.id = $1
LIMIT 1
`

type GetChangesetChangeRow struct {
	ID                             uint
	CreatedAt                      time.Time
	ChangesetID                    uint
	Type                           ChangesetChangeType
	Kind                           ChangesetChangeKind
	FeatureVersionID               *uint
	PreviousFeatureVersionID       *uint
	ServiceVersionID               uint
	PreviousServiceVersionID       *uint
	FeatureVersionServiceVersionID *uint
	KeyID                          *uint
	NewVariationValueID            *uint
	OldVariationValueID            *uint
	VariationContextID             *uint
}

func (q *Queries) GetChangesetChange(ctx context.Context, changeID uint) (GetChangesetChangeRow, error) {
	row := q.db.QueryRow(ctx, getChangesetChange, changeID)
	var i GetChangesetChangeRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.ChangesetID,
		&i.Type,
		&i.Kind,
		&i.FeatureVersionID,
		&i.PreviousFeatureVersionID,
		&i.ServiceVersionID,
		&i.PreviousServiceVersionID,
		&i.FeatureVersionServiceVersionID,
		&i.KeyID,
		&i.NewVariationValueID,
		&i.OldVariationValueID,
		&i.VariationContextID,
	)
	return i, err
}

const getChangesetChanges = `-- name: GetChangesetChanges :many
WITH links AS (
    SELECT
        fvsv.id AS feature_version_service_version_id,
        fv.feature_id AS feature_id,
        fvsv.service_version_id
    FROM
        feature_version_service_versions fvsv
        JOIN feature_versions fv ON fv.id = fvsv.feature_version_id
    WHERE
        fvsv.valid_from IS NOT NULL
        AND fvsv.valid_to IS NULL
),
last_feature_versions AS (
    SELECT
        fv.feature_id,
        MAX(fv.version)::int AS last_version
    FROM
        feature_versions fv
    WHERE
        fv.valid_from IS NOT NULL
        AND fv.valid_to IS NULL
    GROUP BY
        fv.feature_id
),
last_service_versions AS (
    SELECT
        sv.service_id,
        MAX(sv.version)::int AS last_version
    FROM
        service_versions sv
    WHERE
        sv.valid_from IS NOT NULL
        AND sv.valid_to IS NULL
    GROUP BY
        sv.service_id
)
SELECT
    csc.id,
    csc.type,
    csc.kind,
    csc.created_at,
    sv.id AS service_version_id,
    csc.previous_service_version_id,
    s.name AS service_name,
    s.id AS service_id,
    sv.version AS service_version,
    sv.published AS service_version_published,
    fv.id AS feature_version_id,
    csc.previous_feature_version_id,
    f.name AS feature_name,
    f.id AS feature_id,
    fv.version AS feature_version,
    fv.valid_to AS feature_version_valid_to,
    k.id AS key_id,
    k.name AS key_name,
    k.valid_to AS key_valid_to,
    k.validators_updated_at AS key_validators_updated_at,
    nv.id AS new_variation_value_id,
    nv.data AS new_variation_value_data,
    ov.id AS old_variation_value_id,
    ov.data AS old_variation_value_data,
    ov.valid_to AS old_variation_value_valid_to,
    vc.id AS variation_context_id,
    fvsv.id AS feature_version_service_version_id,
    fvsv.valid_to AS feature_version_service_version_valid_to,
    evv.variation_context_id AS existing_variation_context_id,
    evv.data AS existing_value_data,
    ek.id AS existing_key_id,
    el.feature_version_service_version_id AS existing_feature_version_service_version_id,
    COALESCE(lfv.last_version, 0) AS last_feature_version_version,
    COALESCE(lsv.last_version, 0) AS last_service_version_version
FROM
    changeset_changes csc
    JOIN service_versions sv ON sv.id = csc.service_version_id
    JOIN services s ON s.id = sv.service_id
    LEFT JOIN feature_version_service_versions fvsv ON fvsv.id = csc.feature_version_service_version_id
    LEFT JOIN feature_versions fv ON fv.id = csc.feature_version_id
    LEFT JOIN features f ON f.id = fv.feature_id
    LEFT JOIN keys k ON k.id = csc.key_id
    LEFT JOIN variation_values nv ON nv.id = csc.new_variation_value_id
    LEFT JOIN variation_values ov ON ov.id = csc.old_variation_value_id
    LEFT JOIN variation_contexts vc ON vc.id = COALESCE(nv.variation_context_id, ov.variation_context_id)
    LEFT JOIN variation_values evv ON evv.variation_context_id = vc.id
        AND evv.key_id = k.id
        AND evv.valid_from IS NOT NULL
        AND evv.valid_to IS NULL
    LEFT JOIN keys ek ON ek.id <> k.id
        AND ek.name = k.name
        AND ek.feature_version_id = k.feature_version_id
        AND ek.valid_from IS NOT NULL
        AND ek.valid_to IS NULL
    LEFT JOIN links el ON el.service_version_id = sv.id
        AND el.feature_id = f.id
    LEFT JOIN last_feature_versions lfv ON lfv.feature_id = f.id
    LEFT JOIN last_service_versions lsv ON lsv.service_id = sv.service_id
WHERE
    changeset_id = $1
ORDER BY
    csc.id
`

type GetChangesetChangesRow struct {
	ID                                     uint
	Type                                   ChangesetChangeType
	Kind                                   ChangesetChangeKind
	CreatedAt                              time.Time
	ServiceVersionID                       uint
	PreviousServiceVersionID               *uint
	ServiceName                            string
	ServiceID                              uint
	ServiceVersion                         int
	ServiceVersionPublished                bool
	FeatureVersionID                       *uint
	PreviousFeatureVersionID               *uint
	FeatureName                            *string
	FeatureID                              *uint
	FeatureVersion                         *int
	FeatureVersionValidTo                  *time.Time
	KeyID                                  *uint
	KeyName                                *string
	KeyValidTo                             *time.Time
	KeyValidatorsUpdatedAt                 *time.Time
	NewVariationValueID                    *uint
	NewVariationValueData                  *string
	OldVariationValueID                    *uint
	OldVariationValueData                  *string
	OldVariationValueValidTo               *time.Time
	VariationContextID                     *uint
	FeatureVersionServiceVersionID         *uint
	FeatureVersionServiceVersionValidTo    *time.Time
	ExistingVariationContextID             *uint
	ExistingValueData                      *string
	ExistingKeyID                          *uint
	ExistingFeatureVersionServiceVersionID *uint
	LastFeatureVersionVersion              int
	LastServiceVersionVersion              int
}

func (q *Queries) GetChangesetChanges(ctx context.Context, changesetID uint) ([]GetChangesetChangesRow, error) {
	rows, err := q.db.Query(ctx, getChangesetChanges, changesetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChangesetChangesRow
	for rows.Next() {
		var i GetChangesetChangesRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Kind,
			&i.CreatedAt,
			&i.ServiceVersionID,
			&i.PreviousServiceVersionID,
			&i.ServiceName,
			&i.ServiceID,
			&i.ServiceVersion,
			&i.ServiceVersionPublished,
			&i.FeatureVersionID,
			&i.PreviousFeatureVersionID,
			&i.FeatureName,
			&i.FeatureID,
			&i.FeatureVersion,
			&i.FeatureVersionValidTo,
			&i.KeyID,
			&i.KeyName,
			&i.KeyValidTo,
			&i.KeyValidatorsUpdatedAt,
			&i.NewVariationValueID,
			&i.NewVariationValueData,
			&i.OldVariationValueID,
			&i.OldVariationValueData,
			&i.OldVariationValueValidTo,
			&i.VariationContextID,
			&i.FeatureVersionServiceVersionID,
			&i.FeatureVersionServiceVersionValidTo,
			&i.ExistingVariationContextID,
			&i.ExistingValueData,
			&i.ExistingKeyID,
			&i.ExistingFeatureVersionServiceVersionID,
			&i.LastFeatureVersionVersion,
			&i.LastServiceVersionVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChangesetChangesCount = `-- name: GetChangesetChangesCount :one
SELECT
    COUNT(*)::integer
FROM
    changeset_changes csc
WHERE
    csc.changeset_id = $1
`

func (q *Queries) GetChangesetChangesCount(ctx context.Context, changesetID uint) (int, error) {
	row := q.db.QueryRow(ctx, getChangesetChangesCount, changesetID)
	var column_1 int
	err := row.Scan(&column_1)
	return column_1, err
}

const getChangesets = `-- name: GetChangesets :many
WITH changeset_services AS (
    SELECT DISTINCT
        cs.id,
        sv.service_id
    FROM
        changesets cs
        JOIN changeset_changes csc ON csc.changeset_id = cs.id
        JOIN service_versions sv ON sv.id = csc.service_version_id
    WHERE
        cs.state = 'committed'
),
user_service_permissions AS (
    SELECT DISTINCT
        service_id
    FROM
        permissions p
    WHERE
        p.kind = 'service'
        AND p.user_id = $3::bigint
        AND p.permission = 'admin'
),
filtered_changesets AS (
    SELECT
        cs.id
    FROM
        changesets cs
    WHERE ($4::bigint IS NULL
        OR cs.user_id = $4::bigint)
    AND ($3::bigint IS NULL
        OR (cs.state = 'committed'
            AND NOT EXISTS (
                SELECT
                    1
                FROM
                    changeset_services sub
                WHERE
                    sub.id = cs.id
                    AND sub.service_id NOT IN (
                        SELECT
                            service_id
                        FROM
                            user_service_permissions))))
),
last_actions AS (
    SELECT DISTINCT ON (changeset_id)
        changeset_id,
        created_at AS last_action_at
    FROM
        changeset_actions
    ORDER BY
        changeset_id,
        created_at DESC
),
action_counts AS (
    SELECT
        changeset_id,
        COUNT(*)::integer AS action_count
    FROM
        changeset_actions
    GROUP BY
        changeset_id
)
SELECT
    cs.id, cs.created_at, cs.updated_at, cs.user_id, cs.state, cs.applied_at,
    COALESCE(la.last_action_at, cs.created_at) AS last_action_at,
    COALESCE(ac.action_count, 0)::integer AS action_count,
    u.name AS user_name,
    COUNT(*) OVER ()::integer AS total_count
    FROM
        filtered_changesets fc
        JOIN changesets cs ON cs.id = fc.id
        JOIN users u ON u.id = cs.user_id
        LEFT JOIN last_actions la ON la.changeset_id = cs.id
        LEFT JOIN action_counts ac ON ac.changeset_id = cs.id
    ORDER BY
        cs.id DESC
    LIMIT $2::integer OFFSET $1::integer
`

type GetChangesetsParams struct {
	Offset     int
	Limit      int
	ApproverID *uint
	UserID     *uint
}

type GetChangesetsRow struct {
	ID           uint
	CreatedAt    time.Time
	UpdatedAt    time.Time
	UserID       uint
	State        ChangesetState
	AppliedAt    *time.Time
	LastActionAt time.Time
	ActionCount  int
	UserName     string
	TotalCount   int
}

func (q *Queries) GetChangesets(ctx context.Context, arg GetChangesetsParams) ([]GetChangesetsRow, error) {
	rows, err := q.db.Query(ctx, getChangesets,
		arg.Offset,
		arg.Limit,
		arg.ApproverID,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChangesetsRow
	for rows.Next() {
		var i GetChangesetsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.State,
			&i.AppliedAt,
			&i.LastActionAt,
			&i.ActionCount,
			&i.UserName,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeleteChangeForVariationContextID = `-- name: GetDeleteChangeForVariationContextID :one
SELECT
    csc.id,
    csc.type,
    vv.id AS variation_value_id,
    vv.data AS variation_value_data
FROM
    changeset_changes csc
    JOIN variation_values vv ON vv.id = csc.old_variation_value_id
WHERE
    csc.changeset_id = $1
    AND vv.variation_context_id = $2
    AND vv.key_id = $3
LIMIT 1
`

type GetDeleteChangeForVariationContextIDParams struct {
	ChangesetID        uint
	VariationContextID uint
	KeyID              uint
}

type GetDeleteChangeForVariationContextIDRow struct {
	ID                 uint
	Type               ChangesetChangeType
	VariationValueID   uint
	VariationValueData string
}

func (q *Queries) GetDeleteChangeForVariationContextID(ctx context.Context, arg GetDeleteChangeForVariationContextIDParams) (GetDeleteChangeForVariationContextIDRow, error) {
	row := q.db.QueryRow(ctx, getDeleteChangeForVariationContextID, arg.ChangesetID, arg.VariationContextID, arg.KeyID)
	var i GetDeleteChangeForVariationContextIDRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.VariationValueID,
		&i.VariationValueData,
	)
	return i, err
}

const getLastAppliedChangeset = `-- name: GetLastAppliedChangeset :one
SELECT
    id, created_at, updated_at, user_id, state, applied_at
FROM
    changesets
WHERE
    applied_at IS NOT NULL
ORDER BY
    applied_at DESC
LIMIT 1
`

func (q *Queries) GetLastAppliedChangeset(ctx context.Context) (Changeset, error) {
	row := q.db.QueryRow(ctx, getLastAppliedChangeset)
	var i Changeset
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.State,
		&i.AppliedAt,
	)
	return i, err
}

const getNextChangesetsRelatedToServiceVersions = `-- name: GetNextChangesetsRelatedToServiceVersions :many
SELECT
    cs.id AS changeset_id
FROM
    changesets cs
    JOIN changeset_changes csc ON csc.changeset_id = cs.id
WHERE
    csc.service_version_id = ANY ($1::bigint[])
    AND cs.applied_at > $2
GROUP BY
    cs.id
HAVING
    COUNT(csc.id) > 0
LIMIT 100
`

type GetNextChangesetsRelatedToServiceVersionsParams struct {
	ServiceVersionIds []uint
	AppliedAfter      *time.Time
}

func (q *Queries) GetNextChangesetsRelatedToServiceVersions(ctx context.Context, arg GetNextChangesetsRelatedToServiceVersionsParams) ([]uint, error) {
	rows, err := q.db.Query(ctx, getNextChangesetsRelatedToServiceVersions, arg.ServiceVersionIds, arg.AppliedAfter)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uint
	for rows.Next() {
		var changeset_id uint
		if err := rows.Scan(&changeset_id); err != nil {
			return nil, err
		}
		items = append(items, changeset_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOpenChangesetIDForUser = `-- name: GetOpenChangesetIDForUser :one
SELECT
    id
FROM
    changesets
WHERE
    user_id = $1
    AND state = 'open'
LIMIT 1
`

func (q *Queries) GetOpenChangesetIDForUser(ctx context.Context, userID uint) (uint, error) {
	row := q.db.QueryRow(ctx, getOpenChangesetIDForUser, userID)
	var id uint
	err := row.Scan(&id)
	return id, err
}

const getRelatedFeatureVersionChangesCount = `-- name: GetRelatedFeatureVersionChangesCount :one
SELECT
    COUNT(*)::integer
FROM
    changeset_changes csc
WHERE
    csc.feature_version_id = $1::bigint
    AND csc.changeset_id = $2
    AND (csc.kind = 'feature_version'
        OR csc.kind = 'key'
        OR csc.kind = 'variation_value')
`

type GetRelatedFeatureVersionChangesCountParams struct {
	FeatureVersionID uint
	ChangesetID      uint
}

func (q *Queries) GetRelatedFeatureVersionChangesCount(ctx context.Context, arg GetRelatedFeatureVersionChangesCountParams) (int, error) {
	row := q.db.QueryRow(ctx, getRelatedFeatureVersionChangesCount, arg.FeatureVersionID, arg.ChangesetID)
	var column_1 int
	err := row.Scan(&column_1)
	return column_1, err
}

const getRelatedKeyChangesCount = `-- name: GetRelatedKeyChangesCount :one
SELECT
    COUNT(*)::integer
FROM
    changeset_changes csc
WHERE
    csc.key_id = $1::bigint
    AND csc.changeset_id = $2
`

type GetRelatedKeyChangesCountParams struct {
	KeyID       uint
	ChangesetID uint
}

func (q *Queries) GetRelatedKeyChangesCount(ctx context.Context, arg GetRelatedKeyChangesCountParams) (int, error) {
	row := q.db.QueryRow(ctx, getRelatedKeyChangesCount, arg.KeyID, arg.ChangesetID)
	var column_1 int
	err := row.Scan(&column_1)
	return column_1, err
}

const getRelatedServiceVersionChangesCount = `-- name: GetRelatedServiceVersionChangesCount :one
SELECT
    COUNT(*)::integer
FROM
    changeset_changes csc
WHERE
    csc.service_version_id = $1
    AND csc.changeset_id = $2
`

type GetRelatedServiceVersionChangesCountParams struct {
	ServiceVersionID uint
	ChangesetID      uint
}

func (q *Queries) GetRelatedServiceVersionChangesCount(ctx context.Context, arg GetRelatedServiceVersionChangesCountParams) (int, error) {
	row := q.db.QueryRow(ctx, getRelatedServiceVersionChangesCount, arg.ServiceVersionID, arg.ChangesetID)
	var column_1 int
	err := row.Scan(&column_1)
	return column_1, err
}

const lockChangesetForUpdate = `-- name: LockChangesetForUpdate :one
SELECT
    cs.id
FROM
    changesets cs
WHERE
    cs.id = $1
FOR UPDATE
`

func (q *Queries) LockChangesetForUpdate(ctx context.Context, changesetID uint) (uint, error) {
	row := q.db.QueryRow(ctx, lockChangesetForUpdate, changesetID)
	var id uint
	err := row.Scan(&id)
	return id, err
}

const setChangesetState = `-- name: SetChangesetState :exec
UPDATE
    changesets
SET
    state = $1,
    applied_at = $2,
    updated_at = now()
WHERE
    id = $3
`

type SetChangesetStateParams struct {
	State       ChangesetState
	AppliedAt   *time.Time
	ChangesetID uint
}

func (q *Queries) SetChangesetState(ctx context.Context, arg SetChangesetStateParams) error {
	_, err := q.db.Exec(ctx, setChangesetState, arg.State, arg.AppliedAt, arg.ChangesetID)
	return err
}
