// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: membership.sql

package db

import (
	"context"
	"time"
)

const createGroup = `-- name: CreateGroup :one
INSERT INTO user_groups(name, created_at)
    VALUES ($1, now())
RETURNING
    id
`

func (q *Queries) CreateGroup(ctx context.Context, name string) (uint, error) {
	row := q.db.QueryRow(ctx, createGroup, name)
	var id uint
	err := row.Scan(&id)
	return id, err
}

const createPermission = `-- name: CreatePermission :one
INSERT INTO permissions(user_id, user_group_id, kind, service_id, feature_id, key_id, permission, variation_context_id)
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING
    id
`

type CreatePermissionParams struct {
	UserID             *uint
	UserGroupID        *uint
	Kind               PermissionKind
	ServiceID          uint
	FeatureID          *uint
	KeyID              *uint
	Permission         PermissionLevel
	VariationContextID *uint
}

func (q *Queries) CreatePermission(ctx context.Context, arg CreatePermissionParams) (uint, error) {
	row := q.db.QueryRow(ctx, createPermission,
		arg.UserID,
		arg.UserGroupID,
		arg.Kind,
		arg.ServiceID,
		arg.FeatureID,
		arg.KeyID,
		arg.Permission,
		arg.VariationContextID,
	)
	var id uint
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users(name, password, global_administrator, created_at)
    VALUES ($1, $2, $3, now())
RETURNING
    id
`

type CreateUserParams struct {
	Name                string
	Password            string
	GlobalAdministrator bool
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (uint, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Name, arg.Password, arg.GlobalAdministrator)
	var id uint
	err := row.Scan(&id)
	return id, err
}

const createUserGroupMembership = `-- name: CreateUserGroupMembership :exec
INSERT INTO user_group_memberships(user_id, user_group_id, created_at)
    VALUES ($1, $2, now())
`

type CreateUserGroupMembershipParams struct {
	UserID      uint
	UserGroupID uint
}

func (q *Queries) CreateUserGroupMembership(ctx context.Context, arg CreateUserGroupMembershipParams) error {
	_, err := q.db.Exec(ctx, createUserGroupMembership, arg.UserID, arg.UserGroupID)
	return err
}

type CreateUsersParams struct {
	Name                string
	Password            string
	GlobalAdministrator bool
	CreatedAt           time.Time
}

const deleteGroup = `-- name: DeleteGroup :exec
UPDATE
    user_groups
SET
    deleted_at = now()
WHERE
    id = $1
`

func (q *Queries) DeleteGroup(ctx context.Context, id uint) error {
	_, err := q.db.Exec(ctx, deleteGroup, id)
	return err
}

const deletePermission = `-- name: DeletePermission :exec
DELETE FROM permissions
WHERE id = $1
`

func (q *Queries) DeletePermission(ctx context.Context, id uint) error {
	_, err := q.db.Exec(ctx, deletePermission, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
UPDATE
    users
SET
    deleted_at = now()
WHERE
    id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uint) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const deleteUserGroupMembership = `-- name: DeleteUserGroupMembership :exec
DELETE FROM user_group_memberships
WHERE user_id = $1
    AND user_group_id = $2
`

type DeleteUserGroupMembershipParams struct {
	UserID      uint
	UserGroupID uint
}

func (q *Queries) DeleteUserGroupMembership(ctx context.Context, arg DeleteUserGroupMembershipParams) error {
	_, err := q.db.Exec(ctx, deleteUserGroupMembership, arg.UserID, arg.UserGroupID)
	return err
}

const getGroupByID = `-- name: GetGroupByID :one
SELECT
    id, created_at, updated_at, deleted_at, name
FROM
    user_groups
WHERE
    id = $1
`

func (q *Queries) GetGroupByID(ctx context.Context, id uint) (UserGroup, error) {
	row := q.db.QueryRow(ctx, getGroupByID, id)
	var i UserGroup
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Name,
	)
	return i, err
}

const getGroupIDByName = `-- name: GetGroupIDByName :one
SELECT
    id
FROM
    user_groups
WHERE
    name = $1
`

func (q *Queries) GetGroupIDByName(ctx context.Context, name string) (uint, error) {
	row := q.db.QueryRow(ctx, getGroupIDByName, name)
	var id uint
	err := row.Scan(&id)
	return id, err
}

const getGroupUsers = `-- name: GetGroupUsers :many
SELECT
    u.id,
    u.name,
    COUNT(*) OVER ()::integer AS total_count
FROM
    users u
    JOIN user_group_memberships ugm ON ugm.user_id = u.id
WHERE
    ugm.user_group_id = $1
ORDER BY
    u.name ASC
LIMIT $3::integer OFFSET $2::integer
`

type GetGroupUsersParams struct {
	ID     uint
	Offset int
	Limit  int
}

type GetGroupUsersRow struct {
	ID         uint
	Name       string
	TotalCount int
}

func (q *Queries) GetGroupUsers(ctx context.Context, arg GetGroupUsersParams) ([]GetGroupUsersRow, error) {
	rows, err := q.db.Query(ctx, getGroupUsers, arg.ID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupUsersRow
	for rows.Next() {
		var i GetGroupUsersRow
		if err := rows.Scan(&i.ID, &i.Name, &i.TotalCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermission = `-- name: GetPermission :one
SELECT
    id, kind, user_id, user_group_id, service_id, feature_id, key_id, variation_context_id, permission, created_at
FROM
    permissions
WHERE
    user_id IS NOT DISTINCT FROM $1
    AND user_group_id IS NOT DISTINCT FROM $2
    AND service_id = $3
    AND feature_id IS NOT DISTINCT FROM $4
    AND key_id IS NOT DISTINCT FROM $5
    AND variation_context_id IS NOT DISTINCT FROM $6
`

type GetPermissionParams struct {
	UserID             *uint
	UserGroupID        *uint
	ServiceID          uint
	FeatureID          *uint
	KeyID              *uint
	VariationContextID *uint
}

func (q *Queries) GetPermission(ctx context.Context, arg GetPermissionParams) (Permission, error) {
	row := q.db.QueryRow(ctx, getPermission,
		arg.UserID,
		arg.UserGroupID,
		arg.ServiceID,
		arg.FeatureID,
		arg.KeyID,
		arg.VariationContextID,
	)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.Kind,
		&i.UserID,
		&i.UserGroupID,
		&i.ServiceID,
		&i.FeatureID,
		&i.KeyID,
		&i.VariationContextID,
		&i.Permission,
		&i.CreatedAt,
	)
	return i, err
}

const getPermissionByID = `-- name: GetPermissionByID :one
SELECT
    id, kind, user_id, user_group_id, service_id, feature_id, key_id, variation_context_id, permission, created_at
FROM
    permissions
WHERE
    id = $1
`

func (q *Queries) GetPermissionByID(ctx context.Context, id uint) (Permission, error) {
	row := q.db.QueryRow(ctx, getPermissionByID, id)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.Kind,
		&i.UserID,
		&i.UserGroupID,
		&i.ServiceID,
		&i.FeatureID,
		&i.KeyID,
		&i.VariationContextID,
		&i.Permission,
		&i.CreatedAt,
	)
	return i, err
}

const getPermissions = `-- name: GetPermissions :many
SELECT
    p.id, p.kind, p.user_id, p.user_group_id, p.service_id, p.feature_id, p.key_id, p.variation_context_id, p.permission, p.created_at
FROM
    users u
    LEFT JOIN user_group_memberships ugm ON ugm.user_id = u.id
    LEFT JOIN user_groups ug ON ug.id = ugm.user_group_id
    JOIN permissions p ON p.user_group_id = ugm.user_group_id
        OR p.user_id = u.id
WHERE
    u.id = $1
    AND (ug.id IS NULL
        OR ug.deleted_at IS NULL)
`

func (q *Queries) GetPermissions(ctx context.Context, userID uint) ([]Permission, error) {
	rows, err := q.db.Query(ctx, getPermissions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.Kind,
			&i.UserID,
			&i.UserGroupID,
			&i.ServiceID,
			&i.FeatureID,
			&i.KeyID,
			&i.VariationContextID,
			&i.Permission,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissionsForEntity = `-- name: GetPermissionsForEntity :many
SELECT
    p.id,
    p.permission,
    u.id AS user_id,
    u.name AS user_name,
    ug.id AS group_id,
    ug.name AS group_name
FROM
    permissions p
    LEFT JOIN users u ON u.id = p.user_id
    LEFT JOIN user_groups ug ON ug.id = p.user_group_id
WHERE
    service_id = $1
    AND feature_id IS NOT DISTINCT FROM $2
    AND key_id IS NOT DISTINCT FROM $3
    AND variation_context_id IS NOT DISTINCT FROM $4
ORDER BY
    p.id ASC
`

type GetPermissionsForEntityParams struct {
	ServiceID          uint
	FeatureID          *uint
	KeyID              *uint
	VariationContextID *uint
}

type GetPermissionsForEntityRow struct {
	ID         uint
	Permission PermissionLevel
	UserID     *uint
	UserName   *string
	GroupID    *uint
	GroupName  *string
}

func (q *Queries) GetPermissionsForEntity(ctx context.Context, arg GetPermissionsForEntityParams) ([]GetPermissionsForEntityRow, error) {
	rows, err := q.db.Query(ctx, getPermissionsForEntity,
		arg.ServiceID,
		arg.FeatureID,
		arg.KeyID,
		arg.VariationContextID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPermissionsForEntityRow
	for rows.Next() {
		var i GetPermissionsForEntityRow
		if err := rows.Scan(
			&i.ID,
			&i.Permission,
			&i.UserID,
			&i.UserName,
			&i.GroupID,
			&i.GroupName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissionsForMembershipObject = `-- name: GetPermissionsForMembershipObject :many
SELECT
    p.id,
    p.kind,
    p.user_id,
    p.user_group_id,
    p.service_id,
    p.feature_id,
    p.key_id,
    p.variation_context_id,
    p.permission,
    s.name AS service_name,
    f.name AS feature_name,
    k.name AS key_name
FROM
    permissions p
    JOIN services s ON s.id = p.service_id
    LEFT JOIN features f ON f.id = p.feature_id
    LEFT JOIN keys k ON k.id = p.key_id
WHERE ($1::bigint IS NULL
    OR p.user_id = $1::bigint
    OR p.user_group_id IN (
        SELECT
            ugm.user_group_id
        FROM
            user_group_memberships ugm
            JOIN user_groups ug ON ug.id = ugm.user_group_id
        WHERE
            ugm.user_id = $1::bigint
            AND ug.deleted_at IS NULL))
AND ($2::bigint IS NULL
    OR p.user_group_id = $2::bigint)
ORDER BY
    p.id ASC
`

type GetPermissionsForMembershipObjectParams struct {
	UserID  *uint
	GroupID *uint
}

type GetPermissionsForMembershipObjectRow struct {
	ID                 uint
	Kind               PermissionKind
	UserID             *uint
	UserGroupID        *uint
	ServiceID          uint
	FeatureID          *uint
	KeyID              *uint
	VariationContextID *uint
	Permission         PermissionLevel
	ServiceName        string
	FeatureName        *string
	KeyName            *string
}

func (q *Queries) GetPermissionsForMembershipObject(ctx context.Context, arg GetPermissionsForMembershipObjectParams) ([]GetPermissionsForMembershipObjectRow, error) {
	rows, err := q.db.Query(ctx, getPermissionsForMembershipObject, arg.UserID, arg.GroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPermissionsForMembershipObjectRow
	for rows.Next() {
		var i GetPermissionsForMembershipObjectRow
		if err := rows.Scan(
			&i.ID,
			&i.Kind,
			&i.UserID,
			&i.UserGroupID,
			&i.ServiceID,
			&i.FeatureID,
			&i.KeyID,
			&i.VariationContextID,
			&i.Permission,
			&i.ServiceName,
			&i.FeatureName,
			&i.KeyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByID = `-- name: GetUserByID :one
SELECT
    id, created_at, updated_at, deleted_at, name, password, global_administrator
FROM
    users
WHERE
    id = $1
    AND deleted_at IS NULL
`

func (q *Queries) GetUserByID(ctx context.Context, userID uint) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, userID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Name,
		&i.Password,
		&i.GlobalAdministrator,
	)
	return i, err
}

const getUserByName = `-- name: GetUserByName :one
SELECT
    id, created_at, updated_at, deleted_at, name, password, global_administrator
FROM
    users
WHERE
    name = $1
    AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetUserByName(ctx context.Context, name string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByName, name)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Name,
		&i.Password,
		&i.GlobalAdministrator,
	)
	return i, err
}

const getUserGroupMembership = `-- name: GetUserGroupMembership :one
SELECT
    user_group_id, user_id
FROM
    user_group_memberships
WHERE
    user_id = $1
    AND user_group_id = $2
`

type GetUserGroupMembershipParams struct {
	UserID      uint
	UserGroupID uint
}

func (q *Queries) GetUserGroupMembership(ctx context.Context, arg GetUserGroupMembershipParams) (UserGroupMembership, error) {
	row := q.db.QueryRow(ctx, getUserGroupMembership, arg.UserID, arg.UserGroupID)
	var i UserGroupMembership
	err := row.Scan(&i.UserGroupID, &i.UserID)
	return i, err
}

const getUserGroups = `-- name: GetUserGroups :many
SELECT
    ug.id,
    ug.name
FROM
    user_groups ug
    JOIN user_group_memberships ugm ON ugm.user_group_id = ug.id
WHERE
    ugm.user_id = $1
`

type GetUserGroupsRow struct {
	ID   uint
	Name string
}

func (q *Queries) GetUserGroups(ctx context.Context, userID uint) ([]GetUserGroupsRow, error) {
	rows, err := q.db.Query(ctx, getUserGroups, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserGroupsRow
	for rows.Next() {
		var i GetUserGroupsRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersAndGroups = `-- name: GetUsersAndGroups :many
WITH filtered_users AS (
    SELECT
        u.id,
        u.name,
        CASE WHEN u.global_administrator THEN
            'global_administrator'
        ELSE
            'user'
        END AS type
    FROM
        users u
    WHERE
        u.deleted_at IS NULL
        AND ($3::text IS NULL
            OR name ILIKE $3::text || '%')
        AND ($4::text IS NULL
            OR $4::text = 'user')
),
filtered_groups AS (
    SELECT
        ug.id,
        ug.name,
        'group' AS type
    FROM
        user_groups ug
    WHERE
        deleted_at IS NULL
        AND ($3::text IS NULL
            OR name ILIKE $3::text || '%')
        AND ($4::text IS NULL
            OR $4 = 'group')
),
combined AS (
    SELECT
        id, name, type
    FROM
        filtered_users
    UNION ALL
    SELECT
        id, name, type
    FROM
        filtered_groups
)
SELECT
    combined.id, combined.name, combined.type,
    COUNT(*) OVER ()::integer AS total_count
    FROM
        combined
    ORDER BY
        combined.name ASC
    LIMIT $2::integer OFFSET $1::integer
`

type GetUsersAndGroupsParams struct {
	Offset int
	Limit  int
	Name   *string
	Type   *string
}

type GetUsersAndGroupsRow struct {
	ID         uint
	Name       string
	Type       string
	TotalCount int
}

func (q *Queries) GetUsersAndGroups(ctx context.Context, arg GetUsersAndGroupsParams) ([]GetUsersAndGroupsRow, error) {
	rows, err := q.db.Query(ctx, getUsersAndGroups,
		arg.Offset,
		arg.Limit,
		arg.Name,
		arg.Type,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersAndGroupsRow
	for rows.Next() {
		var i GetUsersAndGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: UpdateUser :exec
UPDATE
    users
SET
    global_administrator = $1,
    updated_at = now()
WHERE
    id = $2
`

type UpdateUserParams struct {
	GlobalAdministrator bool
	ID                  uint
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser, arg.GlobalAdministrator, arg.ID)
	return err
}
