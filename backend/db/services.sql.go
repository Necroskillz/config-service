// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: services.sql

package db

import (
	"context"
	"time"
)

const createService = `-- name: CreateService :one
INSERT INTO services(name, description, service_type_id)
    VALUES ($1, $2, $3)
RETURNING
    id
`

type CreateServiceParams struct {
	Name          string
	Description   string
	ServiceTypeID uint
}

func (q *Queries) CreateService(ctx context.Context, arg CreateServiceParams) (uint, error) {
	row := q.db.QueryRow(ctx, createService, arg.Name, arg.Description, arg.ServiceTypeID)
	var id uint
	err := row.Scan(&id)
	return id, err
}

const createServiceVersion = `-- name: CreateServiceVersion :one
INSERT INTO service_versions(service_id, version)
    VALUES ($1, $2)
RETURNING
    id
`

type CreateServiceVersionParams struct {
	ServiceID uint
	Version   int
}

func (q *Queries) CreateServiceVersion(ctx context.Context, arg CreateServiceVersionParams) (uint, error) {
	row := q.db.QueryRow(ctx, createServiceVersion, arg.ServiceID, arg.Version)
	var id uint
	err := row.Scan(&id)
	return id, err
}

const deleteService = `-- name: DeleteService :exec
DELETE FROM services
WHERE id = $1
`

func (q *Queries) DeleteService(ctx context.Context, serviceID uint) error {
	_, err := q.db.Exec(ctx, deleteService, serviceID)
	return err
}

const deleteServiceVersion = `-- name: DeleteServiceVersion :exec
DELETE FROM service_versions
WHERE id = $1
`

func (q *Queries) DeleteServiceVersion(ctx context.Context, serviceVersionID uint) error {
	_, err := q.db.Exec(ctx, deleteServiceVersion, serviceVersionID)
	return err
}

const endServiceVersionValidity = `-- name: EndServiceVersionValidity :exec
UPDATE
    service_versions
SET
    valid_to = $1
WHERE
    id = $2
`

type EndServiceVersionValidityParams struct {
	ValidTo          *time.Time
	ServiceVersionID uint
}

func (q *Queries) EndServiceVersionValidity(ctx context.Context, arg EndServiceVersionValidityParams) error {
	_, err := q.db.Exec(ctx, endServiceVersionValidity, arg.ValidTo, arg.ServiceVersionID)
	return err
}

const getServiceAdmins = `-- name: GetServiceAdmins :many
SELECT
    s.id AS service_id,
    s.name AS service_name,
    u.id AS user_id,
    u.name AS user_name
FROM
    services s
    JOIN user_permissions up ON up.service_id = s.id
        AND up.kind = 'service'
        AND up.permission = 'admin'
    JOIN users u ON u.id = up.user_id
WHERE ($1::bigint IS NULL
    OR s.id = $1::bigint)
AND ($2::bigint IS NULL
    OR u.id = $2::bigint)
`

type GetServiceAdminsParams struct {
	ServiceID *uint
	UserID    *uint
}

type GetServiceAdminsRow struct {
	ServiceID   uint
	ServiceName string
	UserID      uint
	UserName    string
}

func (q *Queries) GetServiceAdmins(ctx context.Context, arg GetServiceAdminsParams) ([]GetServiceAdminsRow, error) {
	rows, err := q.db.Query(ctx, getServiceAdmins, arg.ServiceID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetServiceAdminsRow
	for rows.Next() {
		var i GetServiceAdminsRow
		if err := rows.Scan(
			&i.ServiceID,
			&i.ServiceName,
			&i.UserID,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceIDByName = `-- name: GetServiceIDByName :one
SELECT
    id
FROM
    services
WHERE
    name = $1
LIMIT 1
`

func (q *Queries) GetServiceIDByName(ctx context.Context, name string) (uint, error) {
	row := q.db.QueryRow(ctx, getServiceIDByName, name)
	var id uint
	err := row.Scan(&id)
	return id, err
}

const getServiceVersion = `-- name: GetServiceVersion :one
WITH last_service_versions AS (
    SELECT
        sv.service_id,
        MAX(sv.version)::int AS last_version
    FROM
        service_versions sv
        JOIN valid_service_versions_in_changeset($1) vsv ON vsv.id = sv.id
    GROUP BY
        sv.service_id
)
SELECT
    sv.id, sv.created_at, sv.updated_at, sv.valid_from, sv.valid_to, sv.service_id, sv.version, sv.published,
    s.name AS service_name,
    s.description AS service_description,
    s.service_type_id AS service_type_id,
    st.name AS service_type_name,
    lsv.last_version AS last_version,
    csc.changeset_id AS changeset_id
FROM
    service_versions sv
    JOIN services s ON s.id = sv.service_id
    JOIN service_types st ON st.id = s.service_type_id
    JOIN last_service_versions lsv ON lsv.service_id = sv.service_id
    JOIN changeset_changes csc ON csc.service_version_id = sv.id
        AND csc.type = 'create'
        AND csc.kind = 'service_version'
    JOIN valid_service_versions_in_changeset($1) vsv ON vsv.id = sv.id
WHERE
    sv.id = $2
LIMIT 1
`

type GetServiceVersionParams struct {
	ChangesetID      uint
	ServiceVersionID uint
}

type GetServiceVersionRow struct {
	ID                 uint
	CreatedAt          time.Time
	UpdatedAt          time.Time
	ValidFrom          *time.Time
	ValidTo            *time.Time
	ServiceID          uint
	Version            int
	Published          bool
	ServiceName        string
	ServiceDescription string
	ServiceTypeID      uint
	ServiceTypeName    string
	LastVersion        int
	ChangesetID        uint
}

func (q *Queries) GetServiceVersion(ctx context.Context, arg GetServiceVersionParams) (GetServiceVersionRow, error) {
	row := q.db.QueryRow(ctx, getServiceVersion, arg.ChangesetID, arg.ServiceVersionID)
	var i GetServiceVersionRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ValidFrom,
		&i.ValidTo,
		&i.ServiceID,
		&i.Version,
		&i.Published,
		&i.ServiceName,
		&i.ServiceDescription,
		&i.ServiceTypeID,
		&i.ServiceTypeName,
		&i.LastVersion,
		&i.ChangesetID,
	)
	return i, err
}

const getServiceVersionByNameAndVersion = `-- name: GetServiceVersionByNameAndVersion :one
SELECT
    sv.id, sv.created_at, sv.updated_at, sv.valid_from, sv.valid_to, sv.service_id, sv.version, sv.published
FROM
    service_versions sv
    JOIN services s ON s.id = sv.service_id
WHERE
    s.name = $1
    AND sv.version = $2
    AND sv.valid_from IS NOT NULL
    AND sv.valid_to IS NULL
LIMIT 1
`

type GetServiceVersionByNameAndVersionParams struct {
	Name    string
	Version int
}

func (q *Queries) GetServiceVersionByNameAndVersion(ctx context.Context, arg GetServiceVersionByNameAndVersionParams) (ServiceVersion, error) {
	row := q.db.QueryRow(ctx, getServiceVersionByNameAndVersion, arg.Name, arg.Version)
	var i ServiceVersion
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ValidFrom,
		&i.ValidTo,
		&i.ServiceID,
		&i.Version,
		&i.Published,
	)
	return i, err
}

const getServiceVersions = `-- name: GetServiceVersions :many
SELECT
    sv.id, sv.created_at, sv.updated_at, sv.valid_from, sv.valid_to, sv.service_id, sv.version, sv.published,
    s.name AS service_name,
    s.description AS service_description,
    s.service_type_id AS service_type_id,
    st.name AS service_type_name
FROM
    service_versions sv
    JOIN services s ON s.id = sv.service_id
    JOIN service_types st ON st.id = s.service_type_id
    JOIN valid_service_versions_in_changeset($1) vsv ON vsv.id = sv.id
ORDER BY
    s.name,
    sv.version ASC
`

type GetServiceVersionsRow struct {
	ID                 uint
	CreatedAt          time.Time
	UpdatedAt          time.Time
	ValidFrom          *time.Time
	ValidTo            *time.Time
	ServiceID          uint
	Version            int
	Published          bool
	ServiceName        string
	ServiceDescription string
	ServiceTypeID      uint
	ServiceTypeName    string
}

func (q *Queries) GetServiceVersions(ctx context.Context, changesetID uint) ([]GetServiceVersionsRow, error) {
	rows, err := q.db.Query(ctx, getServiceVersions, changesetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetServiceVersionsRow
	for rows.Next() {
		var i GetServiceVersionsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ValidFrom,
			&i.ValidTo,
			&i.ServiceID,
			&i.Version,
			&i.Published,
			&i.ServiceName,
			&i.ServiceDescription,
			&i.ServiceTypeID,
			&i.ServiceTypeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceVersionsForService = `-- name: GetServiceVersionsForService :many
SELECT
    sv.id,
    sv.version
FROM
    service_versions sv
    JOIN valid_service_versions_in_changeset($1) vsv ON vsv.id = sv.id
WHERE
    sv.service_id = $2
ORDER BY
    sv.version ASC
`

type GetServiceVersionsForServiceParams struct {
	ChangesetID uint
	ServiceID   uint
}

type GetServiceVersionsForServiceRow struct {
	ID      uint
	Version int
}

func (q *Queries) GetServiceVersionsForService(ctx context.Context, arg GetServiceVersionsForServiceParams) ([]GetServiceVersionsForServiceRow, error) {
	rows, err := q.db.Query(ctx, getServiceVersionsForService, arg.ChangesetID, arg.ServiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetServiceVersionsForServiceRow
	for rows.Next() {
		var i GetServiceVersionsForServiceRow
		if err := rows.Scan(&i.ID, &i.Version); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publishServiceVersion = `-- name: PublishServiceVersion :exec
UPDATE
    service_versions
SET
    published = TRUE,
    updated_at = now()
WHERE
    id = $1
`

func (q *Queries) PublishServiceVersion(ctx context.Context, serviceVersionID uint) error {
	_, err := q.db.Exec(ctx, publishServiceVersion, serviceVersionID)
	return err
}

const startServiceVersionValidity = `-- name: StartServiceVersionValidity :exec
UPDATE
    service_versions
SET
    valid_from = $1
WHERE
    id = $2
`

type StartServiceVersionValidityParams struct {
	ValidFrom        *time.Time
	ServiceVersionID uint
}

func (q *Queries) StartServiceVersionValidity(ctx context.Context, arg StartServiceVersionValidityParams) error {
	_, err := q.db.Exec(ctx, startServiceVersionValidity, arg.ValidFrom, arg.ServiceVersionID)
	return err
}

const updateService = `-- name: UpdateService :exec
UPDATE
    services
SET
    description = $1,
    updated_at = now()
WHERE
    id = $2
`

type UpdateServiceParams struct {
	Description string
	ServiceID   uint
}

func (q *Queries) UpdateService(ctx context.Context, arg UpdateServiceParams) error {
	_, err := q.db.Exec(ctx, updateService, arg.Description, arg.ServiceID)
	return err
}
