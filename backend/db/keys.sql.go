// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: keys.sql

package db

import (
	"context"
	"time"
)

const createKey = `-- name: CreateKey :one
INSERT INTO keys(name, description, value_type_id, feature_version_id)
    VALUES ($1, $2, $3, $4)
RETURNING
    id
`

type CreateKeyParams struct {
	Name             string
	Description      *string
	ValueTypeID      uint
	FeatureVersionID uint
}

func (q *Queries) CreateKey(ctx context.Context, arg CreateKeyParams) (uint, error) {
	row := q.db.QueryRow(ctx, createKey,
		arg.Name,
		arg.Description,
		arg.ValueTypeID,
		arg.FeatureVersionID,
	)
	var id uint
	err := row.Scan(&id)
	return id, err
}

type CreateKeysParams struct {
	Name             string
	Description      *string
	ValueTypeID      uint
	FeatureVersionID uint
}

const createValueType = `-- name: CreateValueType :one
INSERT INTO value_types(name, kind)
    VALUES ($1, $2)
RETURNING
    id
`

type CreateValueTypeParams struct {
	Name string
	Kind ValueTypeKind
}

func (q *Queries) CreateValueType(ctx context.Context, arg CreateValueTypeParams) (uint, error) {
	row := q.db.QueryRow(ctx, createValueType, arg.Name, arg.Kind)
	var id uint
	err := row.Scan(&id)
	return id, err
}

const createValueValidatorForKey = `-- name: CreateValueValidatorForKey :one
INSERT INTO value_validators(key_id, validator_type, parameter, error_text)
    VALUES ($1, $2, $3, $4)
RETURNING
    id
`

type CreateValueValidatorForKeyParams struct {
	KeyID         *uint
	ValidatorType ValueValidatorType
	Parameter     *string
	ErrorText     *string
}

func (q *Queries) CreateValueValidatorForKey(ctx context.Context, arg CreateValueValidatorForKeyParams) (uint, error) {
	row := q.db.QueryRow(ctx, createValueValidatorForKey,
		arg.KeyID,
		arg.ValidatorType,
		arg.Parameter,
		arg.ErrorText,
	)
	var id uint
	err := row.Scan(&id)
	return id, err
}

const createValueValidatorForValueType = `-- name: CreateValueValidatorForValueType :one
INSERT INTO value_validators(value_type_id, validator_type, parameter, error_text)
    VALUES ($1, $2, $3, $4)
RETURNING
    id
`

type CreateValueValidatorForValueTypeParams struct {
	ValueTypeID   *uint
	ValidatorType ValueValidatorType
	Parameter     *string
	ErrorText     *string
}

func (q *Queries) CreateValueValidatorForValueType(ctx context.Context, arg CreateValueValidatorForValueTypeParams) (uint, error) {
	row := q.db.QueryRow(ctx, createValueValidatorForValueType,
		arg.ValueTypeID,
		arg.ValidatorType,
		arg.Parameter,
		arg.ErrorText,
	)
	var id uint
	err := row.Scan(&id)
	return id, err
}

type CreateValueValidatorsParams struct {
	KeyID         *uint
	ValueTypeID   *uint
	ValidatorType ValueValidatorType
	Parameter     *string
	ErrorText     *string
}

const deleteKey = `-- name: DeleteKey :exec
DELETE FROM keys
WHERE id = $1
`

func (q *Queries) DeleteKey(ctx context.Context, keyID uint) error {
	_, err := q.db.Exec(ctx, deleteKey, keyID)
	return err
}

const deleteValueValidatorsForKey = `-- name: DeleteValueValidatorsForKey :exec
DELETE FROM value_validators
WHERE key_id = $1::bigint
`

func (q *Queries) DeleteValueValidatorsForKey(ctx context.Context, keyID uint) error {
	_, err := q.db.Exec(ctx, deleteValueValidatorsForKey, keyID)
	return err
}

const endKeyValidity = `-- name: EndKeyValidity :exec
UPDATE
    keys
SET
    valid_to = $1
WHERE
    id = $2
`

type EndKeyValidityParams struct {
	ValidTo *time.Time
	KeyID   uint
}

func (q *Queries) EndKeyValidity(ctx context.Context, arg EndKeyValidityParams) error {
	_, err := q.db.Exec(ctx, endKeyValidity, arg.ValidTo, arg.KeyID)
	return err
}

const getAppliedKeys = `-- name: GetAppliedKeys :many
SELECT DISTINCT
    k.name
FROM
    keys k
WHERE
    k.valid_from IS NOT NULL
    AND ($1::bigint IS NULL
        OR k.feature_version_id = $1::bigint)
    AND ($2::bigint IS NULL
        OR EXISTS (
            SELECT
                1
            FROM
                feature_versions fv
            WHERE
                fv.feature_id = $2::bigint
                AND fv.id = k.feature_version_id))
`

type GetAppliedKeysParams struct {
	FeatureVersionID *uint
	FeatureID        *uint
}

func (q *Queries) GetAppliedKeys(ctx context.Context, arg GetAppliedKeysParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getAppliedKeys, arg.FeatureVersionID, arg.FeatureID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKey = `-- name: GetKey :one
SELECT
    k.id, k.created_at, k.updated_at, k.valid_from, k.valid_to, k.name, k.description, k.value_type_id, k.feature_version_id, k.validators_updated_at,
    vt.kind AS value_type_kind,
    vt.name AS value_type_name,
    csc.changeset_id AS created_in_changeset_id
FROM
    keys k
    JOIN value_types vt ON vt.id = k.value_type_id
    JOIN changeset_changes csc ON csc.key_id = k.id
        AND csc.type = 'create'
        AND csc.kind = 'key'
    JOIN valid_keys_in_changeset($1) vk ON vk.id = k.id
WHERE
    k.id = $2
LIMIT 1
`

type GetKeyParams struct {
	ChangesetID uint
	KeyID       uint
}

type GetKeyRow struct {
	ID                   uint
	CreatedAt            time.Time
	UpdatedAt            time.Time
	ValidFrom            *time.Time
	ValidTo              *time.Time
	Name                 string
	Description          *string
	ValueTypeID          uint
	FeatureVersionID     uint
	ValidatorsUpdatedAt  time.Time
	ValueTypeKind        ValueTypeKind
	ValueTypeName        string
	CreatedInChangesetID uint
}

func (q *Queries) GetKey(ctx context.Context, arg GetKeyParams) (GetKeyRow, error) {
	row := q.db.QueryRow(ctx, getKey, arg.ChangesetID, arg.KeyID)
	var i GetKeyRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ValidFrom,
		&i.ValidTo,
		&i.Name,
		&i.Description,
		&i.ValueTypeID,
		&i.FeatureVersionID,
		&i.ValidatorsUpdatedAt,
		&i.ValueTypeKind,
		&i.ValueTypeName,
		&i.CreatedInChangesetID,
	)
	return i, err
}

const getKeyIDByName = `-- name: GetKeyIDByName :one
SELECT
    k.id
FROM
    keys k
    JOIN valid_keys_in_changeset($1) vk ON vk.id = k.id
WHERE
    k.name = $2
    AND k.feature_version_id = $3
LIMIT 1
`

type GetKeyIDByNameParams struct {
	ChangesetID      uint
	Name             string
	FeatureVersionID uint
}

func (q *Queries) GetKeyIDByName(ctx context.Context, arg GetKeyIDByNameParams) (uint, error) {
	row := q.db.QueryRow(ctx, getKeyIDByName, arg.ChangesetID, arg.Name, arg.FeatureVersionID)
	var id uint
	err := row.Scan(&id)
	return id, err
}

const getKeysForFeatureVersion = `-- name: GetKeysForFeatureVersion :many
SELECT
    k.id, k.created_at, k.updated_at, k.valid_from, k.valid_to, k.name, k.description, k.value_type_id, k.feature_version_id, k.validators_updated_at,
    vt.kind AS value_type_kind,
    vt.name AS value_type_name
FROM
    keys k
    JOIN value_types vt ON vt.id = k.value_type_id
    JOIN valid_keys_in_changeset($1) vk ON vk.id = k.id
WHERE
    k.feature_version_id = $2
ORDER BY
    k.name
`

type GetKeysForFeatureVersionParams struct {
	ChangesetID      uint
	FeatureVersionID uint
}

type GetKeysForFeatureVersionRow struct {
	ID                  uint
	CreatedAt           time.Time
	UpdatedAt           time.Time
	ValidFrom           *time.Time
	ValidTo             *time.Time
	Name                string
	Description         *string
	ValueTypeID         uint
	FeatureVersionID    uint
	ValidatorsUpdatedAt time.Time
	ValueTypeKind       ValueTypeKind
	ValueTypeName       string
}

func (q *Queries) GetKeysForFeatureVersion(ctx context.Context, arg GetKeysForFeatureVersionParams) ([]GetKeysForFeatureVersionRow, error) {
	rows, err := q.db.Query(ctx, getKeysForFeatureVersion, arg.ChangesetID, arg.FeatureVersionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetKeysForFeatureVersionRow
	for rows.Next() {
		var i GetKeysForFeatureVersionRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ValidFrom,
			&i.ValidTo,
			&i.Name,
			&i.Description,
			&i.ValueTypeID,
			&i.FeatureVersionID,
			&i.ValidatorsUpdatedAt,
			&i.ValueTypeKind,
			&i.ValueTypeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKeysForWipFeatureVersion = `-- name: GetKeysForWipFeatureVersion :many
SELECT
    id, created_at, updated_at, valid_from, valid_to, name, description, value_type_id, feature_version_id, validators_updated_at
FROM
    keys
WHERE
    feature_version_id = $1
`

func (q *Queries) GetKeysForWipFeatureVersion(ctx context.Context, featureVersionID uint) ([]Key, error) {
	rows, err := q.db.Query(ctx, getKeysForWipFeatureVersion, featureVersionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Key
	for rows.Next() {
		var i Key
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ValidFrom,
			&i.ValidTo,
			&i.Name,
			&i.Description,
			&i.ValueTypeID,
			&i.FeatureVersionID,
			&i.ValidatorsUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValueType = `-- name: GetValueType :one
SELECT
    id, kind, name
FROM
    value_types
WHERE
    id = $1
`

func (q *Queries) GetValueType(ctx context.Context, id uint) (ValueType, error) {
	row := q.db.QueryRow(ctx, getValueType, id)
	var i ValueType
	err := row.Scan(&i.ID, &i.Kind, &i.Name)
	return i, err
}

const getValueTypeValueValidators = `-- name: GetValueTypeValueValidators :many
SELECT
    id, value_type_id, key_id, validator_type, parameter, error_text
FROM
    value_validators
WHERE
    value_type_id IS NOT NULL
`

func (q *Queries) GetValueTypeValueValidators(ctx context.Context) ([]ValueValidator, error) {
	rows, err := q.db.Query(ctx, getValueTypeValueValidators)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ValueValidator
	for rows.Next() {
		var i ValueValidator
		if err := rows.Scan(
			&i.ID,
			&i.ValueTypeID,
			&i.KeyID,
			&i.ValidatorType,
			&i.Parameter,
			&i.ErrorText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValueTypes = `-- name: GetValueTypes :many
SELECT
    id, kind, name
FROM
    value_types
`

func (q *Queries) GetValueTypes(ctx context.Context) ([]ValueType, error) {
	rows, err := q.db.Query(ctx, getValueTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ValueType
	for rows.Next() {
		var i ValueType
		if err := rows.Scan(&i.ID, &i.Kind, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValueValidators = `-- name: GetValueValidators :many
SELECT
    id, value_type_id, key_id, validator_type, parameter, error_text
FROM
    value_validators
WHERE
    value_type_id = $1
    OR key_id = $2
`

type GetValueValidatorsParams struct {
	ValueTypeID *uint
	KeyID       *uint
}

func (q *Queries) GetValueValidators(ctx context.Context, arg GetValueValidatorsParams) ([]ValueValidator, error) {
	rows, err := q.db.Query(ctx, getValueValidators, arg.ValueTypeID, arg.KeyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ValueValidator
	for rows.Next() {
		var i ValueValidator
		if err := rows.Scan(
			&i.ID,
			&i.ValueTypeID,
			&i.KeyID,
			&i.ValidatorType,
			&i.Parameter,
			&i.ErrorText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startKeyValidity = `-- name: StartKeyValidity :exec
UPDATE
    keys
SET
    valid_from = $1
WHERE
    id = $2
`

type StartKeyValidityParams struct {
	ValidFrom *time.Time
	KeyID     uint
}

func (q *Queries) StartKeyValidity(ctx context.Context, arg StartKeyValidityParams) error {
	_, err := q.db.Exec(ctx, startKeyValidity, arg.ValidFrom, arg.KeyID)
	return err
}

const updateKey = `-- name: UpdateKey :exec
UPDATE
    keys
SET
    description = $1,
    validators_updated_at = $2,
    updated_at = now()
WHERE
    id = $3
`

type UpdateKeyParams struct {
	Description         *string
	ValidatorsUpdatedAt time.Time
	KeyID               uint
}

func (q *Queries) UpdateKey(ctx context.Context, arg UpdateKeyParams) error {
	_, err := q.db.Exec(ctx, updateKey, arg.Description, arg.ValidatorsUpdatedAt, arg.KeyID)
	return err
}
