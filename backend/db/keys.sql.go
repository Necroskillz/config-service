// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: keys.sql

package db

import (
	"context"
	"time"
)

const createKey = `-- name: CreateKey :one
INSERT INTO keys (
        name,
        description,
        value_type_id,
        feature_version_id
    )
VALUES (
        $1,
        $2,
        $3,
        $4
    )
RETURNING id
`

type CreateKeyParams struct {
	Name             string
	Description      *string
	ValueTypeID      uint
	FeatureVersionID uint
}

func (q *Queries) CreateKey(ctx context.Context, arg CreateKeyParams) (uint, error) {
	row := q.db.QueryRow(ctx, createKey,
		arg.Name,
		arg.Description,
		arg.ValueTypeID,
		arg.FeatureVersionID,
	)
	var id uint
	err := row.Scan(&id)
	return id, err
}

const createValueType = `-- name: CreateValueType :one
INSERT INTO value_types (name, kind)
VALUES ($1, $2)
RETURNING id
`

type CreateValueTypeParams struct {
	Name string
	Kind ValueTypeKind
}

func (q *Queries) CreateValueType(ctx context.Context, arg CreateValueTypeParams) (uint, error) {
	row := q.db.QueryRow(ctx, createValueType, arg.Name, arg.Kind)
	var id uint
	err := row.Scan(&id)
	return id, err
}

const createValueValidatorForKey = `-- name: CreateValueValidatorForKey :one
INSERT INTO value_validators (key_id, validator_type, parameter, error_text)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreateValueValidatorForKeyParams struct {
	KeyID         *uint
	ValidatorType ValueValidatorType
	Parameter     *string
	ErrorText     *string
}

func (q *Queries) CreateValueValidatorForKey(ctx context.Context, arg CreateValueValidatorForKeyParams) (uint, error) {
	row := q.db.QueryRow(ctx, createValueValidatorForKey,
		arg.KeyID,
		arg.ValidatorType,
		arg.Parameter,
		arg.ErrorText,
	)
	var id uint
	err := row.Scan(&id)
	return id, err
}

const createValueValidatorForValueType = `-- name: CreateValueValidatorForValueType :one
INSERT INTO value_validators (value_type_id, validator_type, parameter, error_text)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreateValueValidatorForValueTypeParams struct {
	ValueTypeID   *uint
	ValidatorType ValueValidatorType
	Parameter     *string
	ErrorText     *string
}

func (q *Queries) CreateValueValidatorForValueType(ctx context.Context, arg CreateValueValidatorForValueTypeParams) (uint, error) {
	row := q.db.QueryRow(ctx, createValueValidatorForValueType,
		arg.ValueTypeID,
		arg.ValidatorType,
		arg.Parameter,
		arg.ErrorText,
	)
	var id uint
	err := row.Scan(&id)
	return id, err
}

const deleteKey = `-- name: DeleteKey :exec
DELETE FROM keys
WHERE id = $1
`

func (q *Queries) DeleteKey(ctx context.Context, keyID uint) error {
	_, err := q.db.Exec(ctx, deleteKey, keyID)
	return err
}

const endKeyValidity = `-- name: EndKeyValidity :exec
UPDATE keys
SET valid_to = $1
WHERE id = $2
`

type EndKeyValidityParams struct {
	ValidTo *time.Time
	KeyID   uint
}

func (q *Queries) EndKeyValidity(ctx context.Context, arg EndKeyValidityParams) error {
	_, err := q.db.Exec(ctx, endKeyValidity, arg.ValidTo, arg.KeyID)
	return err
}

const getActiveKeysForFeatureVersion = `-- name: GetActiveKeysForFeatureVersion :many
SELECT k.id, k.created_at, k.updated_at, k.valid_from, k.valid_to, k.name, k.description, k.value_type_id, k.feature_version_id,
    vt.kind as value_type_kind,
    vt.name as value_type_name
FROM keys k
    JOIN value_types vt ON vt.id = k.value_type_id
WHERE k.feature_version_id = $1
    AND (
        (
            k.valid_from IS NOT NULL
            AND k.valid_to IS NULL
            AND NOT EXISTS (
                SELECT csc.id
                FROM changeset_changes csc
                WHERE csc.changeset_id = $2
                    AND csc.kind = 'key'
                    AND csc.type = 'delete'
                    AND csc.key_id = k.id
                LIMIT 1
            )
        )
        OR (
            k.valid_from IS NULL
            AND EXISTS (
                SELECT csc.id
                FROM changeset_changes csc
                WHERE csc.changeset_id = $2
                    AND csc.kind = 'key'
                    AND csc.type = 'create'
                    AND csc.key_id = k.id
                LIMIT 1
            )
        )
    )
ORDER BY k.name
`

type GetActiveKeysForFeatureVersionParams struct {
	FeatureVersionID uint
	ChangesetID      uint
}

type GetActiveKeysForFeatureVersionRow struct {
	ID               uint
	CreatedAt        time.Time
	UpdatedAt        time.Time
	ValidFrom        *time.Time
	ValidTo          *time.Time
	Name             string
	Description      *string
	ValueTypeID      uint
	FeatureVersionID uint
	ValueTypeKind    ValueTypeKind
	ValueTypeName    string
}

func (q *Queries) GetActiveKeysForFeatureVersion(ctx context.Context, arg GetActiveKeysForFeatureVersionParams) ([]GetActiveKeysForFeatureVersionRow, error) {
	rows, err := q.db.Query(ctx, getActiveKeysForFeatureVersion, arg.FeatureVersionID, arg.ChangesetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveKeysForFeatureVersionRow
	for rows.Next() {
		var i GetActiveKeysForFeatureVersionRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ValidFrom,
			&i.ValidTo,
			&i.Name,
			&i.Description,
			&i.ValueTypeID,
			&i.FeatureVersionID,
			&i.ValueTypeKind,
			&i.ValueTypeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKey = `-- name: GetKey :one
SELECT k.id, k.created_at, k.updated_at, k.valid_from, k.valid_to, k.name, k.description, k.value_type_id, k.feature_version_id,
    vt.kind as value_type_kind,
    vt.name as value_type_name
FROM keys k
    JOIN value_types vt ON vt.id = k.value_type_id
WHERE k.id = $1
LIMIT 1
`

type GetKeyRow struct {
	ID               uint
	CreatedAt        time.Time
	UpdatedAt        time.Time
	ValidFrom        *time.Time
	ValidTo          *time.Time
	Name             string
	Description      *string
	ValueTypeID      uint
	FeatureVersionID uint
	ValueTypeKind    ValueTypeKind
	ValueTypeName    string
}

func (q *Queries) GetKey(ctx context.Context, keyID uint) (GetKeyRow, error) {
	row := q.db.QueryRow(ctx, getKey, keyID)
	var i GetKeyRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ValidFrom,
		&i.ValidTo,
		&i.Name,
		&i.Description,
		&i.ValueTypeID,
		&i.FeatureVersionID,
		&i.ValueTypeKind,
		&i.ValueTypeName,
	)
	return i, err
}

const getKeyIDByName = `-- name: GetKeyIDByName :one
SELECT id
FROM keys
WHERE name = $1
    AND feature_version_id = $2
LIMIT 1
`

type GetKeyIDByNameParams struct {
	Name             string
	FeatureVersionID uint
}

func (q *Queries) GetKeyIDByName(ctx context.Context, arg GetKeyIDByNameParams) (uint, error) {
	row := q.db.QueryRow(ctx, getKeyIDByName, arg.Name, arg.FeatureVersionID)
	var id uint
	err := row.Scan(&id)
	return id, err
}

const getValueTypeValueValidators = `-- name: GetValueTypeValueValidators :many
SELECT id, value_type_id, key_id, validator_type, parameter, error_text
FROM value_validators
WHERE value_type_id IS NOT NULL
`

func (q *Queries) GetValueTypeValueValidators(ctx context.Context) ([]ValueValidator, error) {
	rows, err := q.db.Query(ctx, getValueTypeValueValidators)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ValueValidator
	for rows.Next() {
		var i ValueValidator
		if err := rows.Scan(
			&i.ID,
			&i.ValueTypeID,
			&i.KeyID,
			&i.ValidatorType,
			&i.Parameter,
			&i.ErrorText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValueTypes = `-- name: GetValueTypes :many
SELECT id, kind, name
FROM value_types
`

func (q *Queries) GetValueTypes(ctx context.Context) ([]ValueType, error) {
	rows, err := q.db.Query(ctx, getValueTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ValueType
	for rows.Next() {
		var i ValueType
		if err := rows.Scan(&i.ID, &i.Kind, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValueValidators = `-- name: GetValueValidators :many
SELECT id, value_type_id, key_id, validator_type, parameter, error_text
FROM value_validators
WHERE value_type_id = $1 OR key_id = $2
`

type GetValueValidatorsParams struct {
	ValueTypeID *uint
	KeyID       *uint
}

func (q *Queries) GetValueValidators(ctx context.Context, arg GetValueValidatorsParams) ([]ValueValidator, error) {
	rows, err := q.db.Query(ctx, getValueValidators, arg.ValueTypeID, arg.KeyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ValueValidator
	for rows.Next() {
		var i ValueValidator
		if err := rows.Scan(
			&i.ID,
			&i.ValueTypeID,
			&i.KeyID,
			&i.ValidatorType,
			&i.Parameter,
			&i.ErrorText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startKeyValidity = `-- name: StartKeyValidity :exec
UPDATE keys
SET valid_from = $1
WHERE id = $2
`

type StartKeyValidityParams struct {
	ValidFrom *time.Time
	KeyID     uint
}

func (q *Queries) StartKeyValidity(ctx context.Context, arg StartKeyValidityParams) error {
	_, err := q.db.Exec(ctx, startKeyValidity, arg.ValidFrom, arg.KeyID)
	return err
}

const updateKey = `-- name: UpdateKey :exec
UPDATE keys
SET description = $1
WHERE id = $2
`

type UpdateKeyParams struct {
	Description *string
	KeyID       uint
}

func (q *Queries) UpdateKey(ctx context.Context, arg UpdateKeyParams) error {
	_, err := q.db.Exec(ctx, updateKey, arg.Description, arg.KeyID)
	return err
}
